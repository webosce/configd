// Copyright (c) 2017-2020 LG Electronics, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

#include <iostream>
#include <stdio.h>
#include <glib.h>
#include <gio/gio.h>
#include <pbnjson.hpp>

#include "Main.h"
#include "DBComparator.h"
#include "database/JsonDB.h"
#include "util/Logger.hpp"
#include "util/Platform.h"

using namespace std;
using namespace pbnjson;

static const gchar *OPTION_SUMMARY =
"configd-tool for debugging and verifying configd internal\n";
static const gchar *OPTION_DESCRIPTION =
"\nExamples:\n\n"

"Print files locations\n"
"$ configd-tool --print\n\n"

"Clean all files which are generated by configd\n"
"$ configd-tool --clean\n"
"{ 'returnValue': true }\n\n"

"Dump in-memory unified database\n"
"$ configd-tool --dump > /tmp/configd_unified_now.json\n"
"%Comparing Result%\n\n"

"Get difference between 2 database files\n"
"$ configd-tool --diff A.json B.json\n"
"{ 'returnValue': true }\n\n"

"Search full name key-value pair containing input key"
"(provide regular expression) from json file\n"
"$ configd-tool --search=settings db.json\n"
"{ 'returnValue': true,\n"
"  'com.palm.app.settings.enableHdmiPcLabel': false,\n"
"  'com.webos.app.quicksettings.disablePictureSettings': false}\n\n"

"Get config from json file\n"
"$ configd-tool --get-config=tv.rmm.ttxMode db.json\n"
"{ 'tv.rmm.ttxMode': 30, 'returnValue': true }\n\n";

static gboolean option_print = FALSE;
static gboolean option_clean = FALSE;
static gboolean option_diff = FALSE;

static gboolean option_dump = FALSE;

static gchar* option_get_config = NULL;
static gchar* option_search = NULL;
static gchar** option_remaining = NULL;

static GOptionEntry OPTION_ENTRIES[] = {
    {
        "print", 0, 0,
        G_OPTION_ARG_NONE, &option_print,
        "print internal information", NULL
    },
    {
        "clean", 0, 0,
        G_OPTION_ARG_NONE, &option_clean,
        "clean up all files", NULL
    },
    {
        "dump", 0, 0,
        G_OPTION_ARG_NONE, &option_dump,
        "dump Config", NULL
    },
    {
        "diff", 0, 0,
        G_OPTION_ARG_NONE, &option_diff,
        "Get differences between two database json files", NULL
    },
    {
        "search", 0, 0,
        G_OPTION_ARG_STRING, &option_search,
        "Search config by regular expression from file database", NULL
    },
    {
        "get-config", 0, 0,
        G_OPTION_ARG_STRING, &option_get_config,
        "Get config value from file database", "%CONFIG_FULLNAME%"
    },
    {
        G_OPTION_REMAINING, 0, 0,
        G_OPTION_ARG_STRING_ARRAY, &option_remaining,
        NULL, NULL
    },
    {
        NULL
    }
};

void printFiles()
{
    cout << "Log file - " << "/var/log/configd.log" << endl;
    cout << "Main DB - " << JsonDB::FILENAME_MAIN_DB << endl;
    cout << "Factory DB - " << JsonDB::FILENAME_FACTORY_DB << endl;
    cout << "Debug DB - " << JsonDB::FILENAME_DEBUG_DB << endl;
    cout << "Dumped DB - " << "/tmp/configd_TIMESTAMP_before_reason.json" << endl;
}

void deleteFiles()
{
    if (Platform::deleteFile(JsonDB::FILENAME_MAIN_DB))
        cout << "MainDB " << JsonDB::FILENAME_MAIN_DB << " deleted" << endl;
    if (Platform::deleteFile(JsonDB::FILENAME_FACTORY_DB))
        cout << "FactoryDB " << JsonDB::FILENAME_FACTORY_DB << " deleted" << endl;
    if (Platform::deleteFile(JsonDB::FILENAME_DEBUG_DB))
        cout << "DebugDB " << JsonDB::FILENAME_DEBUG_DB << " deleted" << endl;
    system("rm /tmp/configd_*");
}

int main(int argc, char *argv[])
{
    GOptionContext* context = g_option_context_new(NULL);
    DBComparator comparator;
    int remaining_size = 0;

    EXIT_STATUS processResult = EXIT_STATUS_Success;
    JValue consoleResult = pbnjson::Object();
    char* errorText = NULL;
    GError* gerror = NULL;

    g_option_context_add_main_entries(context, OPTION_ENTRIES, NULL);
    g_option_context_set_summary(context, OPTION_SUMMARY);
    g_option_context_set_description(context, OPTION_DESCRIPTION);
    if (!g_option_context_parse(context, &argc, &argv, &gerror)) {
        // Check the return value of fprintf
        if (fprintf(stderr, "Option parsing error: %s\n", gerror->message) < 0) {
            perror("fprintf error");
        }
        processResult = EXIT_STATUS_Invalid_arguments;
        goto Exit;
    }

    // Log level needs to be Error
    // because automation use console output
    Logger::getInstance()->setLogLevel(LogLevel_Error);
    if (option_remaining)
        remaining_size = g_strv_length(option_remaining);
    if (option_print) {
        printFiles();
    } else if (option_clean) {
        deleteFiles();
    } else if (option_diff && remaining_size == 2) {
        comparator.setBase(option_remaining[0]);
        consoleResult = DBComparator::compareTwoFiles(option_remaining[0], option_remaining[1]);
        if (consoleResult.objectSize() <= 0) {
            errorText = (char*)"failed to load input files";
            goto Exit;
        }
    } else if (option_dump) {
        JsonDB::getUnifiedInstance().copy(JsonDB::getMainInstance());
        JsonDB::getUnifiedInstance().merge(JsonDB::getFactoryInstance());
        if (JsonDB::getUnifiedInstance().getDatabase().isNull()) {
            errorText = (char*)"Database parsing error";
            goto Exit;
        }
        consoleResult = JsonDB::getUnifiedInstance().getDatabase();
        if (consoleResult.isNull()) {
            errorText = (char*)"Failed to generate unified db";
            goto Exit;
        }
    } else if (option_search != NULL && remaining_size == 1) {
        JsonDB db;
        db.load(option_remaining[0]);
        if (!db.searchKey(option_search, consoleResult)) {
            errorText = (char*)"Cannot search from database";
            goto Exit;
        }
        if (consoleResult.isNull() || consoleResult.objectSize() == 0) {
            errorText = (char*)"Cannot find config matched input regular expression";
            goto Exit;
        }
    } else if (option_get_config != NULL && remaining_size == 1) {
        DBComparator comparator;
        comparator.setBase(option_remaining[0]);

        consoleResult = comparator.getConfig(option_get_config);
        if (consoleResult.isNull() || consoleResult.objectSize() == 0) {
            errorText = (char*)"Cannot find config";
            goto Exit;
        }
    } else {
        errorText = (char*)"Invalid Parameter";
        goto Exit;
    }

Exit:
    if (gerror) {
        consoleResult.put("returnValue", false);
        consoleResult.put("errorText", gerror->message);
        g_error_free(gerror);
    } else if (errorText != NULL) {
        consoleResult.put("returnValue", false);
        consoleResult.put("errorText", errorText);
    } else {
        consoleResult.put("returnValue", true);
    }

    cout << consoleResult.stringify("    ") << endl;

    if (option_get_config) {
        g_free(option_get_config);
    }
    if (remaining_size > 0 && option_remaining) {
        g_strfreev(option_remaining);
    }
    if (context) {
        g_option_context_free(context);
    }
    return processResult;
}
